/*
 * Copyright 2023 cloud7
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app.cloud7.shift.core

import app.cloud7.shift.data.Tick

/**
 * Represents a signal that can be generated by a trading strategy.
 */
sealed trait Signal

/**
 * Companion object for the [[Signal]] trait.
 */
object Signal {

  /**
   * A signal to buy a security.
   */
  case object Buy extends Signal

  /**
   * A signal to sell a security.
   */
  case object Sell extends Signal

  /**
   * A signal to hold a security.
   */
  case object Hold extends Signal
}

/**
 * Represents a trading strategy with methods to define entry and exit conditions.
 *
 * @tparam T the type of the tick data used by the strategy
 */
trait Strategy[T <: Tick] {

  val uuid: String = java.util.UUID.randomUUID.toString

  /**
   * Determines if the strategy should enter a position based on the given tick data.
   *
   * @param tick the current tick data
   * @return true if the strategy should enter a position, false otherwise
   */
  def shouldEnter(tick: T): Boolean

  /**
   * Determines if the strategy should exit a position based on the given tick data.
   *
   * @param tick the current tick data
   * @return true if the strategy should exit a position, false otherwise
   */
  def shouldExit(tick: T): Boolean

  /**
   * Determines the action the strategy suggests based on the current tick data.
   *
   * @param tick the current tick data
   * @return the suggested action for the strategy based on the current tick data
   */
  def onTick(tick: T): Signal = {
    if (shouldEnter(tick)) Signal.Buy
    else if (shouldExit(tick)) Signal.Sell
    else Signal.Hold
  }
}

/**
 * Companion object for the [[Strategy]] trait.
 */
object Strategy {

  def apply(enterRule: Rule[Tick], exitRule: Rule[Tick]): Strategy[Tick] =
    new Strategy[Tick] {
      override def shouldEnter(tick: Tick): Boolean = enterRule.isSatisfiedBy(tick)

      override def shouldExit(tick: Tick): Boolean = exitRule.isSatisfiedBy(tick)
    }
}
